---
import PostHeader from "./post-header.astro";

import { getCollection } from "astro:content";

const allPosts = await getCollection("posts");

const { queryFilters, heading, nbPosts, hasCover = false, articleHeaderContentClass } = Astro.props;


const tagFilters: string[] = [].concat( queryFilters?.tags || ["all"]);

const postFilters: string[] = [].concat( queryFilters?.posts || [""] );

const filteredByDraftStatus = allPosts.filter( post => post.data.status === 'published')

const filteredByTag = filteredByDraftStatus.filter( post =>
  tagFilters.includes("all") || post.data.tags.some( tag => tagFilters.includes(tag))
);

const filteredBySlug = filteredByTag.filter( post => { 
  const slug = post.slug;
  return !postFilters.includes(slug);
})

const posts = nbPosts ? filteredBySlug.slice(0, nbPosts) : filteredBySlug;

posts.sort((a, b) => b.data.pubDate.valueOf() - a.data.pubDate.valueOf());

---
{posts.length > 0 && (
  <>
  {heading && (
      <hr>
      <span set:html={heading}></span>
    )}
  </>
  <ul id="all-posts">
    {posts.map(async (post) => {
        return (
          <li>
            <article class="post-preview">
              <PostHeader hasCover={hasCover} coverSrc={post.data.cover?.src} coverAlt={post.data.cover?.src} url={`${import.meta.env.BASE_URL}${post.slug}`} title={post.data.title} titleTag='h2' description={post.data.description} descriptionTag = 'p' pubDate={post.data.pubDate} tags={post.data.tags} articleHeaderContentClass={articleHeaderContentClass}/>
            </article>
          </li>

        );
      })
    }
  </ul>
)
}
